# Ödev1

1. JavaScript nedir ve tarihsel gelişiminden bahsedin

JavaScript, [Brendan Eich](https://www.google.com/search?sca_esv=575755605&q=Brendan+Eich&si=ALGXSlYh1-GEPndq7qMo--O-TPixQtNN4JMroSxgItz5kq0stOtk3MR2PK1MW62c_g68umDUwPYvdjOu-VvCYdLZJnFkjEjhy4bfTWACvLEAemSbmrJuid5V53UdEX9AvBbdn-mpOeMNg8oEwFy8Nr889gJMfpqOylZiuUJHPb2eisHJawQ7A1k-vI2ESyFsFBMoAfLdm3bZ&sa=X&ved=2ahUKEwiFr4vLhYyCAxVHX_EDHTpiAjgQmxMoAXoECEsQAw) tarafından tasarlanan, HTML ve CSS ile birlikte World Wide Web'in temel teknolojilerinden biri olan programlama dilidir. Web sitelerinin %97'sinden fazlası, web sayfası hareketleri için istemci tarafında JavaScript kullanırlar ve kullanılan kodlar genellikle üçüncü taraf kitaplıkları içerir.

JavaScript'in tarihi, 1990 ların sonlarına dayanır ve o zamandan bu yana büyük bir gelişme göstermiştir. İşte JavaScript'in tarihi ve önemli kilometre taşları:

- **1995: İlk JavaScript Sürümü -** Netscape Communications, web tarayıcıları için JavaScript'i geliştirmeye başladı ve ilk sürümü Navigator 2.0'da tanıttı.

- **1996: JavaScript Standartlaştırması -** JavaScript, ECMAScript adı altında bir standart haline geldi. ECMAScript, dilin tanımını ve özelliklerini belirler.

- **2000: ECMAScript 3.0 -** ECMAScript 3, JavaScript'in yaygın olarak kullanılan bir versiyonu haline geldi ve tarayıcılar bu sürümü desteklemeye başladı.

- **2005: AJAX'ın Yükselişi -** Asenkron JavaScript ve XML (AJAX), web uygulamalarının daha dinamik ve etkileşimli hale gelmesini sağlayan bir teknoloji olarak popüler hale geldi.

- **2009: ECMAScript 5.1 -** Bu sürümle birlikte JavaScript diline birçok yeni özellik eklendi ve eksiklikler giderildi.

- **2015: ECMAScript 6 (ES6) / ECMAScript 2015 -** Bu büyük güncellemeyle birçok yeni dil özelliği ve sözdizimi güncellemeleri tanıtıldı. Bu sürüm, daha önceki sürümlere göre çok daha modern ve gelişmiş bir JavaScript dilini standartlaştırıldı.

- **2016 ve Sonrası: Yıllık Güncellemeler -** ECMAScript artık yıllık güncellemelerle geliyor. Her yıl yeni özellikler ekleniyor ve dil sürekli olarak gelişiyor.

- **2017: Async/Await -** ECMAScript 2017 ile async/await sözdizimi tanıtıldı, bu da asenkron işlemlerin yönetimini kolaylaştırdı.

- **2019: ECMAScript 2019 -** Bu sürümle birlikte Array.flat(), Array.flatMap() gibi yeni yöntemler ve özellikler eklendi.

- **2020 ve Sonrası: Güncellemeler Devam Ediyor -** ECMAScript, her yıl yeni özelliklerle güncellenmeye devam ediyor. Modülerlik, performans ve güvenlik iyileştirmeleri de bu güncellemelerin bir parçası olmuştur.

- **2021: ECMAScript 2021 -** Bu sürümle birlikte yeni özellikler eklenmiştir, özellikle String.prototype.replaceAll() ve Promise.any() gibi.

JavaScript'in gelişimi sadece dilin kendisi ile sınırlı değildir; tarayıcılar, sunucu tarafı uygulamalar ve çeşitli çerçeveler (frameworks) ve kütüphaneler de JavaScript ekosistemini büyük ölçüde etkileyerek daha güçlü ve kullanıcı dostu uygulamaların geliştirilmesine olanak tanımıştır. Bu nedenle, JavaScript'in evrimi sürekli devam etmektedir.

2. Java ile javascript arasındaki fark nedir

Java ve JavaScript, isim benzerliği dışında birbirinden oldukça farklı iki programlama dilidir. İşte Java ve JavaScript arasındaki temel farklar:

1. Dil Türü:

   - Java: Java, bir nesne yönelimli programlama (OOP) dilidir. Genellikle sunucu uygulamaları, masaüstü uygulamaları ve mobil uygulamalar gibi çeşitli platformlarda kullanılır.
   - JavaScript: JavaScript, bir tarayıcı tarafı betik dilidir. Web tarayıcılarında çalışır ve web sayfalarını etkileşimli hale getirmek için kullanılır.

2. Çalıştırma Ortamı:

   - Java: Java uygulamaları bağımsız çalışabilen uygulamalardır. Java kodu bir Java Sanal Makinesi (JVM) üzerinde çalıştırılır ve genellikle derlenmiş bytecode olarak dağıtılır.
   - JavaScript: JavaScript, web tarayıcıları tarafından doğrudan yorumlanan bir betik dilidir. Tarayıcıda çalışır ve web sayfalarında kullanılır.

3. Kullanım Alanları:

   - Java: Java, çok sayıda uygulama türünde kullanılabilir, özellikle sunucu uygulamaları (Java EE veya Spring gibi), Android mobil uygulamaları ve büyük ölçekli yazılımlar için tercih edilir.
   - JavaScript: JavaScript, web geliştirmeye odaklanır. Web sayfalarını canlandırmak, kullanıcı etkileşimlerini kontrol etmek ve web tabanlı uygulamalar geliştirmek için kullanılır.

4. Sözdizimi:

   - Java: Java'nın sözdizimi C++ ile benzerdir ve daha katı bir dil yapısına sahiptir. Bağımsız değişken türleri, sınıflar ve nesneler gibi OOP kavramları içerir.
   - JavaScript: JavaScript, daha gevşek bir sözdizimine sahiptir ve dinamik tür atama özelliğine sahiptir. Nesne tabanlıdır ancak daha esnek ve hızlı bir şekilde kod yazımına izin verir.

5. Derleme:
   - Java: Java, kodun derlenmesi gereken bir dilidir. Java kodu önce bytecode'a derlenir ve JVM tarafından çalıştırılır.
   - JavaScript: JavaScript, kaynak kodu doğrudan yorumlanır ve derlemeye gerek yoktur.

Java ve JavaScript arasındaki farklar, kullanıldıkları alanlar ve kullanım amaçları göz önüne alındığında oldukça belirgindir. Java daha geniş bir uygulama yelpazesi sunarken, JavaScript özellikle web geliştirmeye odaklanır.

1. **Primitive (İlkel) Veriler:**

   1. Primitive veriler, basit ve tek bir değeri temsil eder. Bunlar JavaScript'in temel veri tipleridir. İşte bazı örnekler:
      1. **String**: Metin verilerini temsil eder. Örnek: "Merhaba, Dünya".
      1. **Number**: Sayıları temsil eder. Örnek: 42, 3.14.
      1. **Boolean**: true veya false gibi mantıksal değerleri temsil eder.
      1. **Undefined**: Değer atanmamış bir değişkeni temsil eder. Örneğin, let x; ifadesiyle tanımlanan x değişkeni undefined olarak kabul edilir.
      1. **Null**: Boş bir değeri temsil eder.
      1. **Symbol**: Benzersiz ve değiştirilemez değerler oluşturmak için kullanılır.

1. **Complex (Karmaşık) Veriler:**
   1. Complex veriler, daha karmaşık yapıları temsil eder ve birden çok değeri içerebilir. Bunlar ilkel verilerin aksine referans tipleridir, yani bellekte bir referansla saklanır ve bu referanslar üzerinden erişilir. İşte bazı örnekler:
      1. **Object**: Nesneler, anahtar-değer çiftlerinden oluşan veri yapılarıdır. Özellikle JSON formatı nesneleri temsil etmek için yaygın olarak kullanılır.
      1. **Array**: Dizi, sıralı verileri depolamak için kullanılır ve birden çok değeri içerebilir.
      1. **Function**: Fonksiyonlar da bir tür karmaşık veridir ve işlevselliği tanımlarlar. JavaScript'te fonksiyonlar birer nesne olarak kabul edilir.
      1. **Date**: Tarih ve saat bilgilerini temsil etmek için kullanılır.
      1. **RegExp (Regular Expression)**: Düzenli ifadeleri temsil etmek için kullanılır.

İlkel veriler, değerlerini doğrudan kopyalar ve kendi bellek yönetimine sahiptir. Yani, bir ilkel verinin kopyalanması sadece değeri kopyalar ve orijinal veriyi etkilemez. Öte yandan, karmaşık veriler referans tipleri olduğundan, bir değişkenin başka bir değişkene atanması sadece referansı kopyalar, bu nedenle orijinal veri üzerinde değişiklik yapılırsa diğer değişkenler de etkilenir.

4. null ile undefined arasıdaki fark nedir açıklayınız

`null` ve `undefined`, JavaScript dilinde değerlerin tanımlı olmama durumlarını temsil eden iki özeldir. Her ikisi de farklı kullanım senaryolarına sahiptir.

1. `null`:

   - `null`, bir değişkenin veya nesnenin bilinçli bir şekilde atanmamış veya değersiz olduğunu göstermek için kullanılır.
   - `null`, programcının belirlediği bir değeri temsil eder. Yani bir değişkenin `null` olması, bu değişkenin değerinin bilinçli olarak boş olduğu anlamına gelir.
   - Örnek kullanım: `let degisken = null;`

2. `undefined`:
   - `undefined`, bir değişkenin veya nesnenin atanmamış veya tanımsız olduğunu gösterir.
   - Değişkenin tanımlanmamış olduğu, bir nesne özelliğinin mevcut olmadığı veya bir fonksiyonun dönüş değeri belirtilmemişse, bu değişkenler veya değerler `undefined` ile temsil edilir.
   - Örnek kullanım:
     ```javascript
     let x;
     console.log(x); // Bu, "undefined" sonucunu verir.
     ```

Genellikle, bir değişkenin başlangıç değeri atanmadığında veya bir nesnenin belirli bir özelliği tanımlanmadığında, JavaScript `undefined` değeri kullanır. Ancak programcı, bir değeri bilinçli olarak boş bırakmak istediğinde `null` kullanabilir.

İşte bazı ek önemli noktalar:

- `null` bir değerdir, ancak `undefined` bir türdür.
- `null`'ın değeri ve türü aynıdır, yani `null` bir değer olarak kabul edilir.
- `undefined` ise bir değişkenin tanımlı olmama durumunu temsil eder ve değeri `undefined`dir.
- JavaScript, değişkenlerin başlangıçta `undefined` olarak atanmasını sağlar.
- `null` ve `undefined` sık sık koşullu ifadelerde veya veri işleme işlemlerinde kullanılır.

5. NaN nedir açıklayınız

`NaN`, JavaScript dilinde "Not-a-Number"ın kısaltmasıdır ve bu değer, sayısal işlemlerde geçerli bir sonucun elde edilemediği veya sayısal olmayan bir değerle matematiksel işlem yapıldığında kullanılır. JavaScript'te `NaN`, bir özel sayısal değerdir ve sayı olmayan bir işlemin sonucunu temsil eder.

`NaN` kullanımı özellikle aşağıdaki senaryolarda karşımıza çıkar:

1. Bir sayısal işlem başarısız olduğunda:

   ```javascript
   let sonuc = 0 / 0; // Bu işlem "NaN" sonucunu verir.
   ```

2. Bir metin dizesini sayıya dönüştürmeye çalışırken hata olduğunda:

   ```javascript
   let metin = "bu bir metin";
   let sayi = parseInt(metin); // Bu dönüşüm işlemi "NaN" sonucunu verir.
   ```

3. Geçersiz bir matematiksel işlemde:
   ```javascript
   let sonuc = Math.sqrt(-1); // Negatif sayıların karekökü "NaN" sonucunu verir.
   ```

`NaN` değeri, özellikle sayısal işlemleri güvence altına almak istediğinizde veya kullanıcı girdilerini doğrulamak istediğinizde önemlidir. JavaScript'te `NaN` değerini kontrol etmek için `isNaN()` fonksiyonu kullanabilirsiniz:

```javascript
let deger = parseInt("bu bir metin");
if (isNaN(deger)) {
  console.log("Dönüşüm başarısız oldu. Değer NaN.");
} else {
  console.log("Değer sayıya dönüştürüldü.");
}
```

Bu şekilde, bir değerin `NaN` olup olmadığını kontrol edebilir ve uygun işlemleri gerçekleştirebilirsiniz.

6. Javascript’te yorum satırı eklemenin kaç farklı yolu vardır

JavaScript'de yorum satırı eklemenin birden fazla yolu vardır. Bu yorumlar, kodunuzu daha açıklanabilir hale getirmek, notlar eklemek veya geçici olarak kod bloklarını devre dışı bırakmak için kullanılır. İşte JavaScript'te yorum satırı eklemenin farklı yolları:

1. Tek Satırlık Yorum:
   JavaScript'de tek satırlık yorumlar iki eğik çizgi (`//`) ile başlar ve o satırın sonuna kadar geçerlidir. Örnek:

   ```javascript
   // Bu bir tek satırlık yorum örneğidir.
   let degisken = 42; // Değişkene bir değer atandı.
   ```

2. Çok Satırlık Yorum:
   Çok satırlı yorumlar, başlangıçta bir eğik çizgi ve yıldız işareti (`/*`) ile başlar ve bir yıldız işareti ve eğik çizgi ile (`*/`) biter. İçindeki her şey yorum olarak kabul edilir. Örnek:

   ```javascript
   /*
   Bu
   bir
   çok
   satırlı
   yorum
   örneğidir.
   */
   ```

3. Geçici Olarak Kodu Devre Dışı Bırakma:
   Bir kod parçasını geçici olarak devre dışı bırakmak için de yorum satırlarını kullanabilirsiniz. Örneğin:

   ```javascript
   /*
   Bu kod geçici olarak devre dışı bırakıldı.
   console.log("Bu kod çalışmayacak.");
   */
   ```

4. Yorum Yapmak için Bağlantılı Yöntem:
   Bazı geliştirme ortamları veya IDE'ler, belirli bir kod bloğunu seçtiğinizde veya belirli bir tuş kombinasyonunu kullandığınızda otomatik olarak yorum eklemenize olanak tanır.

Yorumlar, kodunuzu anlaşılır ve bakımı kolay hale getirmek için önemlidir, bu nedenle kodunuzun herhangi bir kısmını açıklamak için yorumlar eklemek iyi bir uygulamadır.

7. Global değişken ne demektir açıklayınız

Global değişken, bir programın veya bir kod bloğunun herhangi bir yerinde tanımlanmış ve erişilebilir olan bir değişkendir. Global değişkenler, programın başından itibaren tanımlandıkları andan itibaren programın sonuna kadar kullanılabilirler ve herhangi bir fonksiyon içinde veya kod bloğunda erişilebilirler.

Global değişkenler, programın farklı bölümleri arasında veri paylaşımını kolaylaştırabilir, ancak aynı zamanda bazı riskler taşır. Global değişkenlerin uygunsuz kullanımı, kodun karmaşıklığını artırabilir ve hata ayıklamayı zorlaştırabilir. Ayrıca, global değişkenlerin yanlışlıkla üzerine yazılması, beklenmedik sonuçlara yol açabilir.

İşte bir JavaScript örneği ile global değişkenin nasıl tanımlandığını ve kullanıldığını gösteren bir örnek:

```javascript
// Global bir değişken tanımlama
let globalDegisken = "Bu bir global değişken";

function fonksiyon1() {
  // Global değişkene erişim
  console.log(globalDegisken);
}

function fonksiyon2() {
  // Global değişkene erişim
  globalDegisken = "Global değişkenin değeri değiştirildi";
}

fonksiyon1(); // "Bu bir global değişken" çıktısı
fonksiyon2();
fonksiyon1(); // "Global değişkenin değeri değiştirildi" çıktısı
```

Yukarıdaki örnekte `globalDegisken`, fonksiyonlar arasında erişilebilir ve değiştirilebilir. Ancak global değişkenlerin yaygın bir şekilde kullanılması yerine, programcılar genellikle yerel değişkenler (sadece belirli bir kod bloğu içinde erişilebilen değişkenler) tercih ederler. Bu, kodun daha modüler ve güvenli olmasına yardımcı olabilir. Global değişkenler, programın gereksinimlerine ve tasarımına bağlı olarak uygun şekilde kullanılmalıdır.

8. Javascript’te this anahtar kelimesi nedir açıklayınız

JavaScript'de `this`, bir işlevin içinde bulunduğu nesneyi veya bir işlevin çağrıldığı bağlamı temsil eden özel bir anahtar kelimedir. `this` kullanarak işlevin hangi nesne veya bağlam içinde çalıştığını anlamak ve bu bağlama erişmek mümkün olur. `this` kavramı, JavaScript'de nesne yönelimli programlamanın önemli bir parçasıdır.

`this`, farklı bağlamlarda farklı değerlere sahip olabilir ve kullanıldığı yere bağlı olarak değişir. İşte bazı yaygın kullanım senaryoları:

1. Global Bağlam:
   `this`, global bağlamda, yani herhangi bir işlevin dışında kullanıldığında, genellikle tarayıcıda `window` nesnesini veya Node.js ortamında `global` nesnesini temsil eder.

   ```javascript
   console.log(this); // Tarayıcıda "window", Node.js'de "global" nesnesini temsil eder.
   ```

2. Nesne Metotları:
   `this`, bir nesne içindeki bir metot içinde kullanıldığında, bu nesneyi temsil eder.

   ```javascript
   const nesne = {
     ad: "Örnek Nesne",
     selamla: function () {
       console.log("Merhaba, " + this.ad);
     },
   };
   nesne.selamla(); // "Merhaba, Örnek Nesne"
   ```

3. İşlev Bağlamı Değiştirme:
   `this` bağlamı, JavaScript'de işlev bağlamı değiştirildiğinde etkileyici bir şekilde değişebilir. Özellikle `bind`, `call` veya `apply` gibi yöntemlerle işlev bağlamı belirli bir nesneye bağlanabilir.

   ```javascript
   const nesne1 = { ad: "Nesne 1" };
   const nesne2 = { ad: "Nesne 2" };

   function selamla() {
     console.log("Merhaba, " + this.ad);
   }

   const baglanmisSelamla = selamla.bind(nesne1);
   baglanmisSelamla(); // "Merhaba, Nesne 1"

   selamla.call(nesne2); // "Merhaba, Nesne 2"
   ```

`this` kullanımı, JavaScript'de nesne yönelimli programlama ve işlevlerin bağlamı hakkında önemli bir kavramdır. İşlevler, işlevi çağıran bağlama bağlı olarak farklı davranabilirler ve bu, nesne tabanlı programlamanın temel özelliklerinden biridir.

9. == ile === farkını örnekler ile açıklayınız

JavaScript'da `==` ve `===` iki farklı karşılaştırma operatörüdür ve değerleri karşılaştırmak için kullanılırlar. Ancak bu iki operatörün davranışları farklıdır:

1. `==` (Eşitlik Operatörü):
   `==` operatörü, iki değeri karşılaştırırken, yalnızca değerlerin eşit olup olmadığını kontrol eder. Değerlerin türleri önemli değildir. Bu operatör, tür dönüşümleri yapabilir ve ardışık veri türleri arasında karşılaştırma yapabilir.

   İşte birkaç örnek:

   ```javascript
   5 == "5"; // true, çünkü değerler aynıdır
   1 == true; // true, çünkü değerler aynıdır
   0 == false; // true, çünkü değerler aynıdır
   ```

   `==` operatörü, tür dönüşümü nedeniyle beklenmedik sonuçlara yol açabilir ve hatalara neden olabilir.

2. `===` (Kesin Eşitlik Operatörü):
   `===` operatörü, iki değerin hem değerlerinin hem de türlerinin eşit olup olmadığını kontrol eder. Bu operatör, tür dönüşümleri yapmaz ve sadece tam eşitlik durumlarını kabul eder.

   İşte birkaç örnek:

   ```javascript
   5 === "5"; // false, çünkü biri sayı, diğeri metindir
   1 === true; // false, çünkü biri sayı, diğeri mantıksal bir değerdir
   0 === false; // false, çünkü biri sayı, diğeri mantıksal bir değerdir
   ```

   `===` operatörü, tür uyumsuzluklarını tespit etmek ve beklenmedik sonuçları önlemek için daha güvenli bir seçenektir.

Sonuç olarak, `==` operatörü sadece değerleri karşılaştırırken, `===` operatörü hem değerleri hem de türleri karşılaştırır. Genel olarak, programcılar tür uyumsuzluklarını önlemek ve beklenmedik davranışları engellemek için `===` operatörünü tercih ederler. Ancak bazı özel durumlarda `==` operatörü kullanılarak tür dönüşümünün istendiği durumlar vardır. Bu nedenle, kullanılacak operatörü seçerken dikkatli olmak önemlidir.

10. let var const farkını tablo yapınız

Aşağıda, JavaScript'te `let`, `var`, ve `const` değişken tanımlama anahtar kelimelerinin farklarını tablo halinde açıklamaya çalıştım:

| Özellik            | `let`        | `var`         | `const`      |
| ------------------ | ------------ | ------------- | ------------ |
| İşlev Kapsamı      | Blok Kapsamı | İşlev Kapsamı | Blok Kapsamı |
| Yeniden Atanabilir | Evet         | Evet          | Hayır        |
| Değiştirilebilir   | Evet         | Evet          | Hayır        |

Bu tablo, `let`, `var`, ve `const`'ın bazı temel farklarını göstermektedir:

1. İşlev Kapsamı: `let` ve `const`, blok kapsamında (örneğin, if bloğu veya döngü içi) tanımlanırken, `var` işlev kapsamında tanımlanır. Bu, `let` ve `const`'ın daha öngörülebilir bir davranış sergilediği anlamına gelir.

2. Yeniden Atanabilirlik: `let` ve `var` değişkenleri yeniden atanabilir (değiştirilebilir) iken, `const` değişkenleri sadece bir kez değer atanabilir ve yeniden atanamaz. Bu, `const` ile tanımlanan bir değişkenin sabit olduğu anlamına gelir.

3. Değiştirilebilirlik: Hem `let` hem de `var` değişkenleri değerleri üzerinde değişiklik yapılabilirken, `const` ile tanımlanan değişkenler sabit olduğu için değerleri değiştirilemez.

4. Değişken Tanımlama: `let` ve `var` ile tanımlanan değişkenler üzerine yazılabilirken (`let x = 10; x = 20;`), `const` ile tanımlanan değişkenler üzerine yazılamaz (`const y = 10; y = 20;` hata verir).

Özetle, `let` ve `const` daha modern ve önerilen değişken tanımlama anahtar kelimeleridir. `let`, yeniden atanabilir değişkenler için kullanılırken, `const`, sabit (değiştirilemeyen) değişkenler için kullanılır. `var`, eski bir değişken tanımlama anahtar kelimesidir ve işlev kapsamında çalışır, bu nedenle genellikle `let` veya `const` ile değiştirilmesi tavsiye edilir.

11. Arrow fonksiyonun normal fonksiyondan farkları nelerdir

Arrow fonksiyonları (ok fonksiyonları), geleneksel fonksiyonlardan (normal fonksiyonlar) bazı önemli farklara sahiptir. İşte arrow fonksiyonlarının normal fonksiyonlardan farkları:

1. Kısa Sözdizimi:
   Arrow fonksiyonları, daha kısa bir sözdizimine sahiptir. Fonksiyonu tanımlamak için `function` kelimesi yerine `=>` (ok işareti) kullanılır.

   Örnek:

   ```javascript
   // Normal fonksiyon
   function topla(a, b) {
     return a + b;
   }

   // Arrow fonksiyon
   const topla = (a, b) => a + b;
   ```

2. `this` Bağlamı:
   Arrow fonksiyonlarının en belirgin özelliği, kendi `this` bağlamını oluşturmamalarıdır. Arrow fonksiyonları, tanımlandıkları kapsamdaki `this` değerini miras alır. Bu nedenle, arrow fonksiyonları, geleneksel fonksiyonlardan farklı bir `this` davranışına sahiptir.

   Örnek:

   ```javascript
   function normalFonksiyon() {
     console.log(this); // global nesne veya belirli bir nesne
   }

   const arrowFonksiyon = () => {
     console.log(this); // arrow fonksiyonunun bulunduğu kapsamdaki this
   };
   ```

3. Argümanların Parantez Olmaması:
   Arrow fonksiyonlarının yalnızca bir argümanı varsa, argümanlar için parantez kullanma zorunluluğu yoktur.

   Örnek:

   ```javascript
   const tekArgumanli = (arguman) => arguman * 2;
   ```

4. Birden Fazla İfade:
   Arrow fonksiyonları yalnızca bir ifade döndüren kısa fonksiyonlar için uygunken, geleneksel fonksiyonlar birden fazla ifadeyi içerebilir ve `return` ifadesi kullanabilir.

   Örnek:

   ```javascript
   // Normal fonksiyon
   function gelenekselFonksiyon() {
     if (true) {
       return "Doğru";
     } else {
       return "Yanlış";
     }
   }

   // Arrow fonksiyon (birden fazla ifade kullanılamaz)
   const arrowFonksiyon = () => {
     if (true) {
       return "Doğru";
     } else {
       return "Yanlış";
     }
   };
   ```

Arrow fonksiyonları, belirli kullanım senaryoları için daha uygun olabilirken, geleneksel fonksiyonlar daha fazla esneklik sağlar ve birden fazla ifadeyi yönetebilir. Bu nedenle, kullanılacak fonksiyon türünü ihtiyaca göre seçmek önemlidir.

12. swich bloğu içinde hatasız nasıl değişken tanımlanır

JavaScript'te bir `switch` ifadesi içinde değişken tanımlamanın iki temel yolunu ele alalım: `case` etiketleri içinde değişken tanımlama ve `switch` ifadesinin dışında değişkeni önceden tanımlama.

1. `case` Etiketleri İçinde Değişken Tanımlama:
   `switch` ifadesi içinde değişkeni tanımlamak için, her `case` etiketi içinde `var`, `let` veya `const` anahtar kelimelerini kullanabilirsiniz. Bu şekilde tanımlanan değişkenler, yalnızca ilgili `case` etiketi içinde erişilebilir olacaktır. Örnek:

   ```javascript
   switch (renk) {
     case "kırmızı":
       let mesaj = "Kırmızı bir obje seçtiniz.";
       console.log(mesaj);
       break;

     case "mavi":
       let mesaj = "Mavi bir obje seçtiniz."; // Hata: "mesaj" zaten tanımlandı
       console.log(mesaj);
       break;

     default:
       let mesaj = "Başka bir obje seçtiniz."; // Hata: "mesaj" zaten tanımlandı
       console.log(mesaj);
   }
   ```

   Yukarıdaki örnekte `let` anahtar kelimesi ile tanımlanan `mesaj` değişkeni, her `case` etiketi içinde aynı isimde tekrar tanımlanmıştır. Bu nedenle, aynı isimdeki değişkenlerin yeniden tanımlanmasına izin verilmeyeceği için hata alırsınız.

2. Değişkeni Önceden Tanımlama:
   `switch` ifadesinin dışında değişkeni tanımlamak ve daha sonra `case` etiketlerinde kullanmak daha hatasız bir yol olabilir. Örnek:

   ```javascript
   let mesaj;

   switch (renk) {
     case "kırmızı":
       mesaj = "Kırmızı bir obje seçtiniz.";
       console.log(mesaj);
       break;

     case "mavi":
       mesaj = "Mavi bir obje seçtiniz.";
       console.log(mesaj);
       break;

     default:
       mesaj = "Başka bir obje seçtiniz.";
       console.log(mesaj);
   }
   ```

Bu şekilde, `mesaj` değişkenini `switch` ifadesinin dışında tanımladığınız için, her `case` etiketi içinde ayrı ayrı tanımlamak zorunda kalmazsınız. Bu, kodun daha temiz ve hatasız olmasına yardımcı olabilir.

13. Pure fonksiyon ne demektir açıklayınız

Pure fonksiyon, programlama teriminin bir parçasıdır ve belirli özelliklere sahip olan bir fonksiyon türünü ifade eder. Bir fonksiyonun "pure" olabilmesi için aşağıdaki özellikleri taşıması gerekir:

1. Aynı Girdiye Her Zaman Aynı Çıktıyı Üretir: Bir pure fonksiyon, aynı girdi değeri veya argümanlarla her zaman aynı sonucu üretir. Girdiler değişmezse, çıktılar da değişmez.

2. Yan Etkisi Yoktur: Pure fonksiyonlar, dış dünya ile etkileşime girmeyen ve herhangi bir yan etki oluşturmayan fonksiyonlardır. Yani, verilen girdilere dayalı olarak bir sonuç üretirler, ancak başka bir değişkeni değiştirmezler veya dış dünyada hiçbir etki yaratmazlar.

3. Referans Değerlere Bağlı Değildir: Pure fonksiyonlar, referans değerlerine dayalı değil, yalnızca argümanların değerlerine dayalı olarak çalışır. Bu, fonksiyonun içindeki değişikliklerin dışarıdaki değişkenlere etki etmediği anlamına gelir.

Pure fonksiyonlar, programlamanın temel prensiplerinden birini olan "fonksiyonel programlama"nın önemli bir parçasıdır. Pure fonksiyonlar, kodun daha öngörülebilir ve test edilebilir olmasını sağlar ve hatalı kodları önlemeye yardımcı olur. Ayrıca, paralel ve dağıtık hesaplamalar gibi bazı programlama konseptlerinde de kullanışlıdır. Pure fonksiyonlar, genellikle state management ve veri işleme işlevlerinde tercih edilir.

14. Rest operatör nedir örnekle açıklayınız

Rest operatörü ve spread operatörü, JavaScript'te benzer görünen ama farklı amaçlara hizmet eden iki farklı operatördür. İşte bu iki operatör arasındaki temel farklar:

1. Rest Operatörü (`...`):

   - Rest operatörü, fonksiyon parametrelerinde veya dizi ve nesne tanımlamalarında kullanılır.
   - Rest operatörü, bir dizi veya nesne içindeki elemanları toplar ve bir dizi içinde kullanılabilir hale getirir. Bu, birden fazla değeri tek bir değişken içinde toplamak veya almak için kullanışlıdır.
   - Rest operatörü, genellikle `...isim` şeklinde kullanılır ve bir isim (genellikle "rest" olarak adlandırılır) ile başlar.

   Örnek Rest Operatör:

   ```javascript
   function toplam(...sayilar) {
     let sonuc = 0;
     for (let sayi of sayilar) {
       sonuc += sayi;
     }
     return sonuc;
   }
   ```

2. Spread Operatörü (`...`):

   - Spread operatörü, dizi veya nesneleri ayırarak elemanlarını genişletmek veya ayrıştırmak için kullanılır.
   - Spread operatörü, dizi veya nesnelerin elemanlarını alır ve bu elemanları ayrı ayrı kullanabilir hale getirir. Bu, özellikle dizi birleştirme veya nesneleri birleştirme işlemlerinde kullanışlıdır.
   - Spread operatörü de genellikle `...` ile başlar, ancak bir değişken ismi izler.

   Örnek Spread Operatör:

   ```javascript
   const dizi1 = [1, 2, 3];
   const dizi2 = [4, 5, 6];

   const birlesikDizi = [...dizi1, ...dizi2];
   ```

Özetle, rest operatörü, dizi veya nesne elemanlarını toplamak veya almak için kullanılırken, spread operatörü elemanları ayırarak dizi veya nesneleri genişletmek veya ayrıştırmak için kullanılır. İkisi de JavaScript kodunu daha esnek ve okunabilir hale getiren önemli araçlardır, ancak kullanıldıkları bağlama bağlı olarak farklı amaçlara hizmet ederler.

15. Object destructuring nedir örnekle açıklayınız

Object destructuring, JavaScript'te bir nesnenin özelliklerini veya değerlerini ayıklayarak ayrıştırma işlemidir. Bu işlem, bir nesnenin içindeki özelliklere veya değerlere kolayca erişmek için kullanılır. Aşağıda object destructuring'i örneklerle açıklayalım:

Örnek 1: Nesne Özelliklerini Ayıklayarak Değişkenlere Atama

```javascript
const kullanici = {
  ad: "John",
  soyad: "Doe",
  yas: 30,
};

// Object destructuring kullanarak nesne özelliklerini ayrıştırma
const { ad, soyad, yas } = kullanici;

console.log(ad); // "John"
console.log(soyad); // "Doe"
console.log(yas); // 30
```

Yukarıdaki örnekte, `kullanici` adlı bir nesnenin özellikleri (`ad`, `soyad`, ve `yas`) object destructuring kullanılarak ayrıştırıldı ve ayrı değişkenlere atanarak erişilebilir hale getirildi.

Örnek 2: Varsayılan Değerlerle Object Destructuring

```javascript
const kitap = {
  baslik: "JavaScript 101",
  yazar: "Ahmet Mehmet",
};

// Eğer `dil` özelliği kitap nesnesinde tanımlanmamışsa, varsayılan değer olarak "Türkçe" kullanılır.
const { baslik, yazar, dil = "Türkçe" } = kitap;

console.log(baslik); // "JavaScript 101"
console.log(yazar); // "Ahmet Mehmet"
console.log(dil); // "Türkçe"
```

Bu örnekte, `dil` özelliği `kitap` nesnesinde tanımlanmadığı için, varsayılan değeri olan "Türkçe" kullanıldı.

Örnek 3: Object Destructuring ile İşlev Parametreleri

```javascript
function kullaniciBilgisi({ ad, soyad, yas }) {
  console.log(`Ad: ${ad}, Soyad: ${soyad}, Yaş: ${yas}`);
}

const kullanici = {
  ad: "Ali",
  soyad: "Veli",
  yas: 25,
};

kullaniciBilgisi(kullanici);
```

Bu örnekte, `kullaniciBilgisi` adlı bir işlev tanımlandı ve bu işlevin parametresi olarak object destructuring kullanıldı. İşlev çağrısında, `kullanici` nesnesi bu işleve aktarıldı ve nesnenin özellikleri ayrıştırıldı.

Object destructuring, JavaScript kodunu daha temiz ve okunabilir hale getirmenin yanı sıra, nesnelerin içindeki değerlere kolayca erişmenizi sağlayan güçlü bir özelliktir.

16. 2 elemanlı bir objeyi 6 farklı şekilde oluşturunuz

2 elemanlı bir JavaScript nesnesini 6 farklı şekilde oluşturabilirsiniz. İşte bu 6 farklı yaklaşım:

Yöntem 1: Object Literal (Nesne Söz dizimi) Kullanarak Oluşturma:

```javascript
const nesne1 = { anahtar1: "değer1", anahtar2: "değer2" };
```

Yöntem 2: Object Constructor (Nesne Oluşturucu) Kullanarak Oluşturma:

```javascript
const nesne2 = new Object();
nesne2.anahtar1 = "değer1";
nesne2.anahtar2 = "değer2";
```

Yöntem 3: Object.create() Metodu Kullanarak Oluşturma:

```javascript
const nesne3 = Object.create({ anahtar1: "değer1", anahtar2: "değer2" });
```

Yöntem 4: Yaratıcı Fonksiyon Kullanarak Oluşturma:

```javascript
function objeOlustur(anahtar1, anahtar2) {
  const nesne4 = {};
  nesne4.anahtar1 = anahtar1;
  nesne4.anahtar2 = anahtar2;
  return nesne4;
}

const nesne4 = objeOlustur("değer1", "değer2");
```

Yöntem 5: Object.assign() Metodu Kullanarak Oluşturma:

```javascript
const nesne5 = Object.assign({}, { anahtar1: "değer1", anahtar2: "değer2" });
```

Yöntem 6: ES6 Yöntemini Kullanarak Oluşturma (Object Shorthand):

```javascript
const anahtar1 = "değer1";
const anahtar2 = "değer2";
const nesne6 = { anahtar1, anahtar2 };
```

Bu altı farklı yöntemle 2 elemanlı bir nesneyi oluşturabilirsiniz. Her yöntem, aynı sonucu verir, ancak farklı sözdizimleri ve yaklaşımları kullanır. Hangi yöntemi kullanacağınız, kodunuzun gereksinimlerine ve okunabilirliğine bağlı olarak değişebilir.

17. 2 elemanlı bir objenin key ve value değerlerinin karakter sayısı ile 2 farklı döngü
    methodu kullanarak yeni bir obje oluşturunuz

2 elemanlı bir nesnenin (objenin) anahtarlarının ve değerlerinin karakter sayısına göre yeni bir nesne oluşturmak için iki farklı döngü yöntemi olan `for...in` döngüsü ve `Object.keys()` ile döngü kullanabiliriz. İşte bu iki yöntemi kullanarak yeni bir nesne oluşturan örnekler:

Örnek 1: `for...in` Döngüsü ile Yeni Nesne Oluşturma:

```javascript
const eskiNesne = { anahtar1: "değer 1", anahtar2: "değer 22" };
const yeniNesne = {};

for (let anahtar in eskiNesne) {
  const deger = eskiNesne[anahtar];
  yeniNesne[anahtar] = deger.length;
}

console.log(yeniNesne);
// Sonuç: { anahtar1: 7, anahtar2: 8 }
```

Örnek 2: `Object.keys()` ve `forEach` ile Yeni Nesne Oluşturma:

```javascript
const eskiNesne = { anahtar1: "değer 1", anahtar2: "değer 22" };
const yeniNesne = {};

Object.keys(eskiNesne).forEach((anahtar) => {
  const deger = eskiNesne[anahtar];
  yeniNesne[anahtar] = deger.length;
});

console.log(yeniNesne);
// Sonuç: { anahtar1: 7, anahtar2: 8 }
```

Her iki örnek de, mevcut nesnenin anahtarlarını ve değerlerini dolaşarak her bir değerin karakter sayısını hesaplar ve yeni bir nesne oluşturur. İlk örnek `for...in` döngüsü kullanırken, ikinci örnek `Object.keys()` ile nesnenin anahtarlarını alır ve `forEach` döngüsünü kullanır. Sonuç olarak, her iki yöntem de aynı sonucu üretir.

18. Cookie, local storage ve session storage farkını tablo yapınız

İşte Cookie, Local Storage ve Session Storage arasındaki temel farkları içeren bir tablo:

| Özellik                        | Cookie                              | Local Storage                               | Session Storage                      |
| ------------------------------ | ----------------------------------- | ------------------------------------------- | ------------------------------------ |
| Veri Türü                      | Metin (string)                      | Metin (string)                              | Metin (string)                       |
| Maksimum Depolama Miktarı      | Yaklaşık 4KB                        | Yaklaşık 5-10MB                             | Yaklaşık 5-10MB                      |
| Tarayıcı Tarafından Gönderilir | Evet                                | Hayır                                       | Hayır                                |
| Sunucu Tarafından Erişilebilir | Evet                                | Hayır                                       | Hayır                                |
| Veri Saklama Süresi            | Belirli sürelerle ayarlanır         | Kalıcı, tarayıcı kapatılana kadar           | Tarayıcı oturumu boyunca             |
| Otomatik Sonlanma Zamanı       | Belirli bir tarih veya süre         | Kalıcı, kullanıcı tarafından silinene kadar | Tarayıcı oturumu sona erdiğinde      |
| HTTP ile Gönderilir            | Evet                                | Hayır                                       | Hayır                                |
| Güvenlik                       | Güvensiz (HTTP Only)                | Güvensiz (HTTP ve HTTPS)                    | Güvensiz (HTTP ve HTTPS)             |
| JavaScript ile Erişim          | Evet                                | Evet                                        | Evet                                 |
| Veri Paylaşımı                 | Farklı alan adları arasında sınırlı | Aynı alan adları arasında paylaşılır        | Aynı alan adları arasında paylaşılır |

Bu tablo, Cookie, Local Storage ve Session Storage arasındaki önemli farkları özetlemektedir. Cookie, kullanıcı tarayıcıları aracılığıyla sunuculara gönderilebilir ve belirli bir süre boyunca saklanabilir. Local Storage ve Session Storage, tarayıcı tarafında veri saklamak için kullanılır, ancak Local Storage kalıcıdır ve kullanıcı tarafından silinmedikçe kalırken, Session Storage sadece tarayıcı oturumu sırasında varlığını sürdürür. Cookie, tüm alan adları arasında paylaşılabilirken, Local Storage ve Session Storage yalnızca aynı alan adları arasında paylaşılabilir.

19. asenkron ve senkron işlem farkı nedir

Senkron (synchronous) ve asenkron (asynchronous) işlem, programlama ve bilgisayar bilimlerinde önemli bir kavramdır ve bu iki işlem türü arasında önemli farklar bulunmaktadır. İşte senkron ve asenkron işlemlerin temel farkları:

1. Senkron İşlem (Synchronous):

   - Senkron işlem, işlemlerin sırasıyla ve adım adım yürütüldüğü bir işlem türüdür.
   - Bir işlem tamamlanmadan diğer işlem başlamaz. Yani, bir işlem bitmeden diğeri başlamaz.
   - Senkron işlemler, kodun okunabilirliği ve sıralanabilirliği açısından avantajlı olabilir.
   - Ancak, senkron işlemler uzun süren işlemleri bekletebilir ve uygulamanın tepki süresini olumsuz etkileyebilir.

2. Asenkron İşlem (Asynchronous):
   - Asenkron işlem, işlemlerin eşzamansız olarak çalıştığı bir işlem türüdür. Yani, bir işlem başladığında diğer işlem beklemeksizin çalışabilir.
   - Bu, uzun süren işlemlerin diğer işlemleri engellemeden çalışmasına olanak tanır ve uygulamanın daha hızlı ve daha duyarlı olmasını sağlayabilir.
   - Asenkron işlemler, olay tabanlı programlamada ve ağ iletişiminde sıkça kullanılır.
   - Asenkron kod, genellikle geri çağrılar (callbacks), Promisler veya async/await yapıları gibi mekanizmalar kullanılarak yönetilir.

Özetle, senkron işlemde işlemler sırayla ve beklemeli bir şekilde gerçekleşirken, asenkron işlemde işlemler eşzamansız olarak çalışabilir ve bir işlem diğerini beklemeksizin devam edebilir. Asenkron işlemler, uzun süren işlemlerle başa çıkmak ve uygulamaları daha hızlı ve daha verimli hale getirmek için yaygın olarak kullanılır.

20. promise nedir ve neden ihtiyaç duyarız

Promise, JavaScript'in asenkron işlemleri yönetmek için kullanılan bir yapıdır. Promise'ler, özellikle ağ istekleri, dosya okuma/yazma işlemleri veya zaman alıcı işlemler gibi uzun süren işlemleri yönetmek için oldukça kullanışlıdır. Promise'ler, bir işlemin sonucunu (başarılı veya başarısız) temsil eden bir nesne olarak işlev görürler.

Promise'lerin neden ihtiyaç duyulduğunu anlamak için bazı senaryoları ele alalım:

1. Asenkron İşlemler:
   JavaScript, tarayıcıda çalışırken veya sunucu tarafında (Node.js gibi) uzun süren işlemlerle karşılaşabilir. Bu işlemler, verileri çekme, kaydetme, hesaplama veya dış kaynaklara erişim gibi görevleri içerebilir. Bu tür işlemleri senkron olarak yapmak, uygulamanın donmasına veya yavaş tepki vermesine neden olabilir. Promise'ler, asenkron işlemleri yönetmek ve uygulamanın duyarlılığını artırmak için kullanılır.

2. Zaman Aşımı Kontrolü:
   Promise'ler, belirli bir süre içinde işlemin tamamlanmasını beklemek ve eğer işlem belirli bir süre içinde sonuçlanmazsa bir hata yönetimi yapmak için kullanılabilir. Bu, ağ isteklerinde veya dış kaynaklara erişimde zaman aşımı durumlarını ele almak için yaygın bir ihtiyaçtır.

3. Daha Temiz ve Okunabilir Kod:
   Promise'ler, geri çağrı (callback) cehennemi olarak bilinen ve kodun karışık ve okunaksız hale gelmesine neden olan karmaşık asenkron işlemleri daha düzenli ve okunabilir bir şekilde ifade etmenize olanak tanır. Bu, kodun bakımını kolaylaştırır.

4. Zincirleme İşlemler:
   Promise'ler, birçok asenkron işlemi birbirine bağlayarak sıralı bir şekilde çalıştırmak için kullanılabilir. Bu, işlemleri belirli bir sıraya göre gerçekleştirmek için idealdir.

Promise'ler, JavaScript'in daha güçlü ve daha karmaşık asenkron işlemleri ele alabilmesini sağlar. Bu nedenle, modern JavaScript uygulamalarının vazgeçilmez bir parçasıdır ve kodun daha düzenli, okunabilir ve yönetilebilir olmasına yardımcı olurlar.
